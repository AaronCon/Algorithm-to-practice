## 队列

### 队列简易实现思想（c++）

> 普通队列

```c++
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;

class Queue {
    public: 
    	Queue(int n = 10): arr(n), head(0), tail(0) {}
    	void push(int x) {
            if(full()) {
                cout << "queue full" << endl;
                return ;
            }
            arr[tail] = x;
            tail += 1;
            return ;
        }	//入队
    	void pop() {
            if(empty()) return;
            head += 1;
        }	//出队
    	bool empty() {
            return head == tail;
        }	//判空
    	bool full() {
            return tail == arr.size();
        }
    	int front() {
            return arr[head];
        }	//查看队首元素
    	int size() {
            return tail - head;
        }
    	void output() {
            for(int i = head; i < tail; i++) {
                cout << arr[i] << " ";
            }
            cout << endl;
            return ;
        }
    
    private:
    	int head, tail;
    	vector<int> arr;
    
}
```

> 循环队列

```c++
#include <cstdlib>
#include <queue>
#include <stack>
#include <algorithm>
#include <string>
#include <map>
#include <set>
#include <vector>
using namespace std;

class Queue {
    public: 
    	Queue(int n = 10): arr(n), head(0), cnt(0), tail(0) {}
    	void push(int x) {
            if(full()) {
                cout << "queue full" << endl;
                return ;
            }
            arr[tail] = x;
            cnt += 1;
            tail += 1;
            if(tail == arr.size()) tail = 0;
            return ;
        }	//入队
    	void pop() {
            if(empty()) return;
            head += 1;
            cnt -= 1;
            if(head == arr.size()) head = 0;
        }	//出队
    	bool empty() {
            return cnt == 0;
        }	//判空
    	bool full() {
            return cnt == arr.size();
        }
    	int front() {
            return arr[head];
        }	//查看队首元素
    	int size() {
            return cnt;
        }
    	void output() {
            for(int i = 0, j = head; i < cnt; i++) {
                cout << arr[i] << " ";
                j += 1;
                if(j = arr.size()) j = 0;
            }
            cout << endl;
            return ;
        }
    
    private:
    	int head, tail;
    	vector<int> arr;
    
}
```

### 链表复习题

[86.分隔链表]: https://leetcode.cn/problems/partition-list/

解题思想：

* 创建两个虚拟头结点，一个接小于x的结点，一个接收大于等于x的结点

* 循环判断链表的结点非空，判断成功，将该结点的下一结点存储

* 然后判断当前结点与x的大小关系，然后将该结点接入到虚拟结点后，然后将虚拟左结点等于当前结点

* 最后拼接虚拟左右结点，形成分隔号的链表结构

  ```javascript
  var partition = function(head, x) {
      let m = new ListNode(0), b = new ListNode(0);
      let l = m, r = b;
      let p = head;
      while(p !== null) {
          let q = p.next;
          if(p.val < x) {
              p.next = null;
              l.next = p;
              l = p;
          } else {
              p.next = null;
              r.next = p;
              r = p;
          }
          p = q;
      }
      l.next = b.next;
      return m.next;
  };
  ```

  

[138.复制带随机指针的链表]: https://leetcode.cn/problems/copy-list-with-random-pointer/

------

### 队列练习题

[622.设计循环队列]: https://leetcode.cn/problems/design-circular-queue/
[641.设计循环双端队列]: https://leetcode.cn/problems/design-circular-deque/
[1670.设计前中后队列]: https://leetcode.cn/problems/design-front-middle-back-queue/
[933.最近的请求次数]: https://leetcode.cn/problems/number-of-recent-calls/

------

### 队列面试题

[第K个数]: https://leetcode.cn/problems/get-kth-magic-number-lcci/
[859.亲密字符串]: https://leetcode.cn/problems/buddy-strings/
[860.柠檬水找零]: https://leetcode.cn/problems/lemonade-change/
[969.煎饼排序]: https://leetcode.cn/problems/pancake-sorting/
[621.任务调度器]: https://leetcode.cn/problems/task-scheduler/

