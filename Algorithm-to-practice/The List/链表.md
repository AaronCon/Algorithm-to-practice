## 链表

### 链表判环(快慢指针)

[141.环形判环]: https://leetcode.cn/problems/linked-list-cycle/

解题思想：

* 先判断head节点是否为空

* 再利用快慢指针来判断，如果两个指针能够相等，则有环，否则快指针首选到尾节点后判断为null，则无环

(在javascript中，return null的结果为true，在c++中，return NULL的结果为false)

------

[142.环形链表]: https://leetcode.cn/problems/linked-list-cycle-ii/

解题思想：

* 如果链表的头节点或者第二个节点为null，则非循环链表

* 然后进行快慢指针的相遇，如果快指针的q.next为null或者q.next.next为null则非循环链表

* 如果快慢指针能够相遇，则说明是循环链表

* 要找到循环的首节点，让慢指针重新从头节点开始走，让快指针恢复成慢指针的速度

* 当他们相遇的时候就是循环链表的首节点

  ------

  [202.快乐数]: https://leetcode.cn/problems/happy-number/

  解题思想：

  * 一个数组的每个位置平方和确定，可想象成链表形式，这个节点指向下一个节点

  * 先写出对应求平方和的方法，对一个数取余并平方，然后依此求下一位的平方

  * 然后将1看作链表中的null值即可按照链表判断有无环的方式进行判断是否为快乐数

    ------

    ### 链表反转

    [206.反转链表]: https://leetcode.cn/problems/reverse-linked-list/

    解题思路：

    1. 利用三个节点进行迭代反转

    * 如果链表为null,则直接返回即可

    * 利用三个节点反转，pre表示反转头，cur表示未反转头，下个带反转头

    2. 利用递归反转

       * 递归从尾节点进行反转

       * 当当前head为null或者head->next为null时表示为尾节点，返回head

       * 然后递归将head->next节点指向head节点

       * 然后将head节点指向null

    ------
    
    [返回倒数第K个节点]: https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/
    
    解题思路：
    
    * 利用前后指针
    
    * 先让前指针先走k-1步
    
    * 然后两个指针再一同走，如果前指针走到尾节点，后指针就在倒数第k个节点
    
      ------
    
      ### 链表删除节点
    
      [19.删除链表的倒数第N个结点]: https://leetcode.cn/problems/remove-nth-node-from-end-of-list/
    
      解题思路：
    
      * 先创建一个虚拟头节点
      * 利用前后指针找到需要删除的节点的前一个节点
      * 将要删除的前一个节点指向被删除节点的后一个节点
      * 然后返回虚拟头节点的下一个节点

